<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ViewUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">PMDB</a> &gt; <a href="index.source.html" class="el_package">org.xandercat.pmdb.util</a> &gt; <span class="el_source">ViewUtil.java</span></div><h1>ViewUtil.java</h1><pre class="source lang-java linenums">package org.xandercat.pmdb.util;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import javax.servlet.http.HttpSession;

import org.springframework.data.util.ReflectionUtils;
import org.springframework.validation.BindingResult;
import org.springframework.validation.MapBindingResult;
import org.springframework.web.multipart.MultipartFile;
import org.xandercat.pmdb.dto.Movie;
import org.xandercat.pmdb.form.Option;
import org.xandercat.pmdb.service.CollectionService;
import org.xandercat.pmdb.service.ImdbAttribute;
import org.xandercat.pmdb.util.format.AbstractDataFormatter;
import org.xandercat.pmdb.util.format.DataFormatter;
import org.xandercat.pmdb.util.format.DataFormatterSelector;
import org.xandercat.pmdb.util.format.DataFormatters;
import org.xandercat.pmdb.util.format.DateFormatter;
import org.xandercat.pmdb.util.format.DoubleFormatter;
import org.xandercat.pmdb.util.format.LongFormatter;
import org.xandercat.pmdb.util.format.StringFormatter;

/**
 * Utility methods for interacting with the view.
 * 
 * @author Scott Arnold
 */
<span class="nc" id="L39">public class ViewUtil {</span>

<span class="fc" id="L41">	public static String TAB_HOME = &quot;isHomeTab&quot;;</span>
<span class="fc" id="L42">	public static String TAB_COLLECTIONS = &quot;isCollectionsTab&quot;;</span>
<span class="fc" id="L43">	public static String TAB_IMDB_SEARCH = &quot;isImdbSearchTab&quot;;</span>
<span class="fc" id="L44">	public static String TAB_USER_ADMIN = &quot;isUserAdminTab&quot;;</span>
<span class="fc" id="L45">	public static String TAB_MY_ACCOUNT = &quot;isMyAccountTab&quot;;</span>
	
<span class="fc" id="L47">	public static String SESSION_NUM_SHARE_OFFERS_KEY = &quot;numShareOffers&quot;;</span>
<span class="fc" id="L48">	public static String SESSION_COLLECTION_UPLOAD_FILE = &quot;importedCollectionFile&quot;;</span>
<span class="fc" id="L49">	public static String SESSION_COLLECTION_UPLOAD_SHEETS = &quot;importedCollectionSheetNames&quot;;</span>
<span class="fc" id="L50">	public static String SESSION_COLLECTION_UPLOAD_COLUMNS = &quot;importedCollectionColumnNames&quot;;</span>
	
	public static void updateNumShareOffers(CollectionService collectionService, HttpSession session, String username) {
<span class="nc" id="L53">		int numShareOffers = collectionService.getShareOfferMovieCollections(username).size();</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">		if (numShareOffers &gt; 0) {</span>
<span class="nc" id="L55">			session.setAttribute(SESSION_NUM_SHARE_OFFERS_KEY, Integer.valueOf(numShareOffers));</span>
		} else {
<span class="nc" id="L57">			session.removeAttribute(SESSION_NUM_SHARE_OFFERS_KEY);</span>
		}
<span class="nc" id="L59">	}</span>
	
	public static MultipartFile getImportedCollectionFile(HttpSession session) {
<span class="nc" id="L62">		return (MultipartFile) session.getAttribute(SESSION_COLLECTION_UPLOAD_FILE);</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	public static List&lt;String&gt; getImportedCollectionSheets(HttpSession session) {
<span class="nc" id="L67">		return (List&lt;String&gt;) session.getAttribute(SESSION_COLLECTION_UPLOAD_SHEETS);</span>
	}
	
	@SuppressWarnings(&quot;unchecked&quot;)
	public static List&lt;String&gt; getImportedCollectionColumns(HttpSession session) {
<span class="nc" id="L72">		return (List&lt;String&gt;) session.getAttribute(SESSION_COLLECTION_UPLOAD_COLUMNS);</span>
	}
	public static void setImportedCollectionFile(HttpSession session, MultipartFile multipartFile, List&lt;String&gt; sheets, List&lt;String&gt; columns) {
<span class="nc" id="L75">		session.setAttribute(SESSION_COLLECTION_UPLOAD_FILE, multipartFile);</span>
<span class="nc" id="L76">		session.setAttribute(SESSION_COLLECTION_UPLOAD_SHEETS, sheets);</span>
<span class="nc" id="L77">		session.setAttribute(SESSION_COLLECTION_UPLOAD_COLUMNS, columns);</span>
<span class="nc" id="L78">	}</span>
	
	public static void clearImportedCollectionFile(HttpSession session) {
<span class="nc" id="L81">		session.removeAttribute(SESSION_COLLECTION_UPLOAD_FILE);</span>
<span class="nc" id="L82">		session.removeAttribute(SESSION_COLLECTION_UPLOAD_SHEETS);</span>
<span class="nc" id="L83">		session.removeAttribute(SESSION_COLLECTION_UPLOAD_COLUMNS);</span>
<span class="nc" id="L84">	}</span>
	
	private static Option reflectOptionWithIntValue(Object item, String valueGetterName, String textGetterName) {
		try {
<span class="fc" id="L88">			Method valueMethod = ReflectionUtils.findRequiredMethod(item.getClass(), valueGetterName, (Class&lt;?&gt;[]) null);</span>
<span class="fc" id="L89">			Method textMethod = ReflectionUtils.findRequiredMethod(item.getClass(), textGetterName, (Class&lt;?&gt;[]) null);</span>
<span class="fc" id="L90">			Object value = valueMethod.invoke(item, (Object[]) null);</span>
<span class="fc" id="L91">			Object text = textMethod.invoke(item, (Object[]) null);</span>
<span class="fc" id="L92">			return new Option(value, text);	</span>
<span class="nc" id="L93">		} catch (Exception e) {</span>
<span class="nc" id="L94">			throw new IllegalArgumentException(&quot;Unable to obtain option text and value with reflection.&quot;);</span>
		}
	}
	
	private static &lt;E extends Enum&lt;E&gt;&gt; Option getOption(E e) {
<span class="fc" id="L99">		return new Option(e.name(), e.toString());</span>
	}
	
	private static Option getOption(String s) {
<span class="nc" id="L103">		return new Option(s, s);</span>
	}
	
	/**
	 * Shortcut method to return list of options for view given collection of objects.  Value field is currently
	 * limited to primitive int type.  Text field is currently limited to String type.
	 * 
	 * @param items            items to create list of options for
	 * @param valueGetterName   getter method name for the value (int type)
	 * @param textGetterName    getter method name for the text (String type)
	 * 
	 * @return list of options for the items
	 */
	public static List&lt;Option&gt; getOptions(Collection&lt;?&gt; items, String valueGetterName, String textGetterName) {
<span class="fc" id="L117">		return items.stream().map(item -&gt; { </span>
<span class="fc" id="L118">			return reflectOptionWithIntValue(item, valueGetterName, textGetterName); </span>
<span class="fc" id="L119">		}).collect(Collectors.toList());</span>
	}
	
	/**
	 * Shortcut method to return list of options for the given enum class type.  Enum name will be used for 
	 * value, and toString() will be used for text.
	 * 
	 * @param enumType  enum class
	 * @return          list of options for enum class
	 */
	public static &lt;E extends Enum&lt;E&gt;&gt; List&lt;Option&gt; getOptions(Class&lt;E&gt; enumType) {
<span class="fc" id="L130">		return Arrays.stream(enumType.getEnumConstants()).map(ViewUtil::getOption).collect(Collectors.toList());</span>
	}
	
	/**
	 * Shortcut method to return list of options for the given collection of strings.  Each String 
	 * will be used for both the value and text of it's returned option.
	 * 
	 * @param strings strings to create options for
	 * @return options for the strings
	 */
	public static List&lt;Option&gt; getOptions(Collection&lt;String&gt; strings) {
<span class="nc" id="L141">		return strings.stream().map(ViewUtil::getOption).collect(Collectors.toList());</span>
	}
	
	/**
	 * Returns an empty binding result.
	 * 
	 * @param objectName object name
	 * 
	 * @return empty binding result
	 */
	public static BindingResult emptyBindingResult(String objectName) {
<span class="fc" id="L152">		return new MapBindingResult(new HashMap&lt;String, String&gt;(), objectName);</span>
	}
	
	/**
	 * Returns DataFormatters for the given collection of movies that is suitable for use with
	 * Thymeleaf and Datatables.net sortable table.
	 * 
	 * @param movies  collection of movies
	 * 
	 * @return DataFormatters for collection of movies
	 */
	public static DataFormatters getDataFormatters(Collection&lt;Movie&gt; movies, Collection&lt;String&gt; attributeNames) {
<span class="fc" id="L164">		DataFormatters dataFormatters = new DataFormatters();</span>
<span class="fc" id="L165">		dataFormatters.setGenericFormatter(stringFormatter());</span>
<span class="fc" id="L166">		dataFormatters.addAttributeFormatter(ImdbAttribute.IMDB_VOTES.getKey(), longFormatter());</span>
<span class="fc" id="L167">		dataFormatters.addAttributeFormatter(ImdbAttribute.IMDB_RATING.getKey(), doubleFormatter(1));</span>
<span class="fc" id="L168">		dataFormatters.addAttributeFormatter(ImdbAttribute.RELEASED.getKey(), dateFormatter(&quot;dd MMM yyyy&quot;));</span>
<span class="fc" id="L169">		dataFormatters.addAttributeFormatter(ImdbAttribute.YEAR.getKey(), stringFormatter()); // will prevent long formatter from trying to long format the year</span>
		
		// create general data formatters for remaining attributes
<span class="fc" id="L172">		List&lt;DataFormatter&gt; generalDataFormatters = new ArrayList&lt;DataFormatter&gt;();</span>
<span class="fc" id="L173">		generalDataFormatters.add(longFormatter());</span>
<span class="fc" id="L174">		generalDataFormatters.add(doubleFormatter(3));</span>
<span class="fc" id="L175">		generalDataFormatters.add(dateFormatter(</span>
				&quot;MM/dd/yyyy&quot;, &quot;yyyy/MM/dd&quot;, &quot;MM-dd-yyyy&quot;, &quot;yyyy-MM-dd&quot;, &quot;M/d/yyyyy&quot;, &quot;dd MMM yyyy&quot;));
		
		// use selectors to select data formatters for remaining attributes
<span class="fc" id="L179">		Set&lt;String&gt; remainingAttributeNames = new HashSet&lt;String&gt;();</span>
<span class="fc" id="L180">		remainingAttributeNames.addAll(attributeNames);</span>
<span class="fc" id="L181">		remainingAttributeNames.removeAll(dataFormatters.getAttributeFormatters().keySet());</span>
<span class="fc" id="L182">		List&lt;DataFormatterSelector&gt; selectors = remainingAttributeNames.stream()</span>
<span class="pc" id="L183">				.map(attrName -&gt; new DataFormatterSelector(attrName, generalDataFormatters))</span>
<span class="fc" id="L184">				.collect(Collectors.toList());</span>
<span class="fc" id="L185">		selectors.stream().forEach(selector -&gt; {</span>
<span class="nc" id="L186">			movies.stream().forEach(movie -&gt; selector.test(movie.getAttribute(selector.getAttributeName())));</span>
<span class="nc" id="L187">			Optional&lt;DataFormatter&gt; dataFormatter = selector.getDataFormatter();</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">			if (dataFormatter.isPresent()) {</span>
<span class="nc" id="L189">				dataFormatters.addAttributeFormatter(selector.getAttributeName(), dataFormatter.get());</span>
			}
<span class="nc" id="L191">		});</span>
		
<span class="fc" id="L193">		return dataFormatters;</span>
	}
	
	private static AbstractDataFormatter&lt;String&gt; stringFormatter() {
		// to ensure datatables works with Thymeleaf, need to have blank space for default sort value
<span class="fc" id="L198">		return new StringFormatter()</span>
<span class="fc" id="L199">				.defaultDisplayValue(&quot;&quot;).defaultSortValue(&quot; &quot;);</span>
	}
	
	private static AbstractDataFormatter&lt;Long&gt; longFormatter() {
<span class="fc" id="L203">		return new LongFormatter()</span>
<span class="fc" id="L204">				.defaultDisplayValue(&quot;&quot;).defaultSortValue(&quot;0&quot;);</span>
	}
	
	private static AbstractDataFormatter&lt;Double&gt; doubleFormatter(int maximumFractionDigits) {
<span class="fc" id="L208">		return new DoubleFormatter(maximumFractionDigits)</span>
<span class="fc" id="L209">				.defaultDisplayValue(&quot;&quot;).defaultSortValue(&quot;0.0&quot;).displayFormattedValue(false);</span>
	}
	
	private static AbstractDataFormatter&lt;Date&gt; dateFormatter(String... parseFormats) {
<span class="fc" id="L213">		return new DateFormatter().parseFormats(parseFormats).defaultDisplayValue(&quot;&quot;).defaultSortValue(&quot; &quot;);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>